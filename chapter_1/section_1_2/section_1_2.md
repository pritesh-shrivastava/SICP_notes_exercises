
## Section 1.2

#### Ex1.9

Each of the following two procedures defines a method for adding two positive integers in terms of the procedures inc, which increments its argument by 1, and dec, which decrements its argument by 1.

```
(define (+ a b)
  (if (= a 0) 
      b 
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0) 
      b 
      (+ (dec a) (inc b))))
```
Using the substitution model, illustrate the process generated by each procedure in evaluating (+ 4 5). Are these processes iterative or recursive?

_Solution_ :

While both functions (procedures) are recursive by syntax, the actual processes are different in both functions.

In the first case, the actual evaluation is delayed until `a` reaches the value 0. The intermediate step at every step is not yet evaluated. The process first expands, and then contracts as shown below. If the function were to crash in between, we cannot start from the break point. There are no state variables that can perfectly define the intermediate resutl. This is a linear recursive process.

```
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
```

In the second case, while the procedure is recursive, the actual process is linearly iterative. Each intermediate state is perfectly defined with the procedure parameters. The process uses constant space at any point in time.
```
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
```

#### Ex1.10

Part 1 : The following procedure computes a mathematical function called Ackermann’s function.
```
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
```
What are the values of the following expressions?
```
(A 1 10)
(A 2 4)
(A 3 3)
```
_Solution_ :

Using the substitution model, 
```
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
(A 0 ( A 0 (A 0 (A 1 7))))
(A 0 ( A 0 (A 0 (A 0 (A 1 6)))))
(A 0 ( A 0 (A 0 (A 0 (A 0 (A 1 5))))))
(A 0 ( A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
(A 0 ( A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
(A 0 ( A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
(A 0 ( A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 ( A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
(A 0 ( A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
(A 0 ( A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
(A 0 ( A 0 (A 0 (A 0 (A 0 (A 0 16))))))
(A 0 ( A 0 (A 0 (A 0 (A 0 32)))))
(A 0 ( A 0 (A 0 (A 0 64))))
(A 0 ( A 0 (A 0 128)))
(A 0 (A 0 256))
(A 0 512)
1024
```

Using results from above to simplify the expression, and extrapolating, (for eg (A 1 4)) 
```
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2))
(A 1 (A 1 4))
(A 1 16)
2^16
```

Again, using above results to simplify, 
```
(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 4)
(A 1 16)
2^16
```

Part 2 : Consider the following procedures, where A is the procedure defined above:

(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
Give concise mathematical definitions for the functions computed by the procedures f, g, and h for positive integer values of n. For example, (k n) computes 5*n^2 .

_Solution_ :
For n > 0 and for integer n, 
(f n) computes 2*n
(g n) computes 2^n
(h n) computes 2^2^2^   (n times)

#### Ex1.11

A function f is defined by the rule that f(n)=n if n<3 and f(n)=f(n−1)+2f(n−2)+3f(n−3) if n≥3. Write a procedure that computes f by means of a recursive process. Write a procedure that computes f by means of an iterative process.

_Solution_ :

Tree recursion - easier to write, but slower to run
```
(define (f_tree_rcrsn n)
  (cond ((< n 3) n)
        (else (+ (f_tree_rcrsn (- n 1))
                (* (f_tree_rcrsn (- n 2)) 2)
		(* (f_tree_rcrsn (- n 3)) 3)
		)
	)
 )
)
```

Iterative process - faster than tree recursion
```
(define (f_iter n) 
	(if (< n 3)
	n
	(f-iter 2 1 0 n)
	)
)

(define (f-iter a b c count)
  (if (< count 3)
      a
      (f-iter (+ a (* 2 b) (* 2 c)) 
		a 
		b 
		(- count 1)
		)
	)
)
```

#### Ex1.12

Exercise 1.12: The following pattern of numbers is called Pascal’s triangle.

         1
       1   1
     1   2   1
   1   3   3   1
 1   4   6   4   1
       . . .
The numbers at the edge of the triangle are all 1, and each number inside the triangle is the sum of the two numbers above it. Write a procedure that computes elements of Pascal’s triangle by means of a recursive process.

_Solution_ : Calculating the elements of the Pascal's Triangle based on row & column (starting from 1, top to down, and left to right respectively). We are ignoring 0 values.

```
(define (pascal row col)
	(if (or ( = col 1) (= col row))
		1
		(+ (pascal (- row 1) col)
		   (pascal (- row 1)( - col 1))		
		)
	)
)
```
